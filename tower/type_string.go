// Code generated by "enumer -type=Type -transform=lower -output=type_string.go"; DO NOT EDIT.

package tower

import (
	"fmt"
	"strings"
)

const _TypeName = "range1range2rangesingel1rangesingel2rangeaoe1rangeaoe2melee1melee2meleesingle1meleesingle2meleeaoe1meleeaoe2"

var _TypeIndex = [...]uint8{0, 6, 12, 24, 36, 45, 54, 60, 66, 78, 90, 99, 108}

const _TypeLowerName = "range1range2rangesingel1rangesingel2rangeaoe1rangeaoe2melee1melee2meleesingle1meleesingle2meleeaoe1meleeaoe2"

func (i Type) String() string {
	if i < 0 || i >= Type(len(_TypeIndex)-1) {
		return fmt.Sprintf("Type(%d)", i)
	}
	return _TypeName[_TypeIndex[i]:_TypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TypeNoOp() {
	var x [1]struct{}
	_ = x[Range1-(0)]
	_ = x[Range2-(1)]
	_ = x[RangeSingel1-(2)]
	_ = x[RangeSingel2-(3)]
	_ = x[RangeAoE1-(4)]
	_ = x[RangeAoE2-(5)]
	_ = x[Melee1-(6)]
	_ = x[Melee2-(7)]
	_ = x[MeleeSingle1-(8)]
	_ = x[MeleeSingle2-(9)]
	_ = x[MeleeAoE1-(10)]
	_ = x[MeleeAoE2-(11)]
}

var _TypeValues = []Type{Range1, Range2, RangeSingel1, RangeSingel2, RangeAoE1, RangeAoE2, Melee1, Melee2, MeleeSingle1, MeleeSingle2, MeleeAoE1, MeleeAoE2}

var _TypeNameToValueMap = map[string]Type{
	_TypeName[0:6]:         Range1,
	_TypeLowerName[0:6]:    Range1,
	_TypeName[6:12]:        Range2,
	_TypeLowerName[6:12]:   Range2,
	_TypeName[12:24]:       RangeSingel1,
	_TypeLowerName[12:24]:  RangeSingel1,
	_TypeName[24:36]:       RangeSingel2,
	_TypeLowerName[24:36]:  RangeSingel2,
	_TypeName[36:45]:       RangeAoE1,
	_TypeLowerName[36:45]:  RangeAoE1,
	_TypeName[45:54]:       RangeAoE2,
	_TypeLowerName[45:54]:  RangeAoE2,
	_TypeName[54:60]:       Melee1,
	_TypeLowerName[54:60]:  Melee1,
	_TypeName[60:66]:       Melee2,
	_TypeLowerName[60:66]:  Melee2,
	_TypeName[66:78]:       MeleeSingle1,
	_TypeLowerName[66:78]:  MeleeSingle1,
	_TypeName[78:90]:       MeleeSingle2,
	_TypeLowerName[78:90]:  MeleeSingle2,
	_TypeName[90:99]:       MeleeAoE1,
	_TypeLowerName[90:99]:  MeleeAoE1,
	_TypeName[99:108]:      MeleeAoE2,
	_TypeLowerName[99:108]: MeleeAoE2,
}

var _TypeNames = []string{
	_TypeName[0:6],
	_TypeName[6:12],
	_TypeName[12:24],
	_TypeName[24:36],
	_TypeName[36:45],
	_TypeName[45:54],
	_TypeName[54:60],
	_TypeName[60:66],
	_TypeName[66:78],
	_TypeName[78:90],
	_TypeName[90:99],
	_TypeName[99:108],
}

// TypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TypeString(s string) (Type, error) {
	if val, ok := _TypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Type values", s)
}

// TypeValues returns all values of the enum
func TypeValues() []Type {
	return _TypeValues
}

// TypeStrings returns a slice of all String values of the enum
func TypeStrings() []string {
	strs := make([]string, len(_TypeNames))
	copy(strs, _TypeNames)
	return strs
}

// IsAType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Type) IsAType() bool {
	for _, v := range _TypeValues {
		if i == v {
			return true
		}
	}
	return false
}
